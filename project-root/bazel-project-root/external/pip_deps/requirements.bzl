"""Starlark representation of locked requirements.

@generated by rules_python pip_parse repository rule.
"""

load("@rules_python//python:pip.bzl", "pip_utils")
load("@rules_python//python/pip_install:pip_repository.bzl", "group_library", "whl_library")

all_requirements = [
    "@pip_deps//colorama:pkg",
    "@pip_deps//exceptiongroup:pkg",
    "@pip_deps//iniconfig:pkg",
    "@pip_deps//packaging:pkg",
    "@pip_deps//pluggy:pkg",
    "@pip_deps//pytest:pkg",
    "@pip_deps//tomli:pkg",
]

all_whl_requirements_by_package = {
    "colorama": "@pip_deps//colorama:whl",
    "exceptiongroup": "@pip_deps//exceptiongroup:whl",
    "iniconfig": "@pip_deps//iniconfig:whl",
    "packaging": "@pip_deps//packaging:whl",
    "pluggy": "@pip_deps//pluggy:whl",
    "pytest": "@pip_deps//pytest:whl",
    "tomli": "@pip_deps//tomli:whl",
}

all_whl_requirements = all_whl_requirements_by_package.values()

all_data_requirements = [
    "@pip_deps//colorama:data",
    "@pip_deps//exceptiongroup:data",
    "@pip_deps//iniconfig:data",
    "@pip_deps//packaging:data",
    "@pip_deps//pluggy:data",
    "@pip_deps//pytest:data",
    "@pip_deps//tomli:data",
]

_packages = [
    ("pip_deps_colorama", "colorama==0.4.6"),
    ("pip_deps_exceptiongroup", "exceptiongroup==1.2.2"),
    ("pip_deps_iniconfig", "iniconfig==2.0.0"),
    ("pip_deps_packaging", "packaging==24.2"),
    ("pip_deps_pluggy", "pluggy==1.5.0"),
    ("pip_deps_pytest", "pytest==8.3.4"),
    ("pip_deps_tomli", "tomli==2.2.1"),
]
_config = {
    "download_only": False,
    "enable_implicit_namespace_pkgs": False,
    "environment": {},
    "envsubst": [],
    "extra_pip_args": [],
    "isolated": True,
    "pip_data_exclude": [],
    "python_interpreter": "python.exe",
    "quiet": True,
    "repo": "pip_deps",
    "repo_prefix": "pip_deps_",
    "timeout": 600,
}
_annotations = {}

def requirement(name):
    return "@pip_deps//{}:{}".format(pip_utils.normalize_name(name), "pkg")

def whl_requirement(name):
    return "@pip_deps//{}:{}".format(pip_utils.normalize_name(name), "whl")

def data_requirement(name):
    return "@pip_deps//{}:{}".format(pip_utils.normalize_name(name), "data")

def dist_info_requirement(name):
    return "@pip_deps//{}:{}".format(pip_utils.normalize_name(name), "dist_info")

def _get_annotation(requirement):
    # This expects to parse `setuptools==58.2.0     --hash=sha256:2551203ae6955b9876741a26ab3e767bb3242dafe86a32a749ea0d78b6792f11`
    # down to `setuptools`.
    name = requirement.split(" ")[0].split("=")[0].split("[")[0]
    return _annotations.get(name)

def install_deps(**whl_library_kwargs):
    """Repository rule macro. Install dependencies from `pip_parse`.

    Args:
       **whl_library_kwargs: Additional arguments which will flow to underlying
         `whl_library` calls. See pip_repository.bzl for details.
    """

    # Set up the requirement groups
    all_requirement_groups = {}

    requirement_group_mapping = {
        requirement: group_name
        for group_name, group_requirements in all_requirement_groups.items()
        for requirement in group_requirements
    }

    group_repo = "pip_deps__groups"
    group_library(
        name = group_repo,
        repo_prefix = "pip_deps_",
        groups = all_requirement_groups,
    )

    # Install wheels which may be participants in a group
    whl_config = dict(_config)
    whl_config.update(whl_library_kwargs)

    for name, requirement in _packages:
        group_name = requirement_group_mapping.get(name.replace("pip_deps_", ""))
        group_deps = all_requirement_groups.get(group_name, [])

        whl_library(
            name = name,
            requirement = requirement,
            group_name = group_name,
            group_deps = group_deps,
            annotation = _get_annotation(requirement),
            **whl_config
        )
